<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0069)http://www.disi.unige.it/person/GianuzziV/MobComp/lucidi/Routing.html -->
<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en" ""><HTML><HEAD><META 
content="IE=5.0000" http-equiv="X-UA-Compatible">
    
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">    
<META name="Author" content="vittoria gianuzzi">    
<META name="KeyWords" content="Ad Hoc Routing Protocols, table driven routing protocol, dynamic destination sequence distance vector , wireless , global state , fisheye state , hierarchical state , zone based hierarchical link state , clusterhead gateway switch , on demand , cluster based , ad hoc on demand distance vector , dynamic source , temporally ordered algorithm, associativity based , signal stability,table driven routing protocol,dynamic destination sequence distance vector,wireless,global state,fisheye state,hierarchical state,zone based hierarchical link state,clusterhead gateway switch,on demand,cluster based,ad hoc on demand distance vector,dynamic source,temporally ordered algorithm,associativity based,signal stability"> 
   
<META name="Classification" content="Technical">    
<META name="GENERATOR" content="MSHTML 10.00.9200.16458">    <TITLE>Routing in 
Manet (1)</TITLE> </HEAD> 
<BODY text="#000000" bgcolor="#fffff7" link="#0000ee" alink="#ff0000" vlink="#365f58">
<CENTER><B><FONT color="#ff0000"><FONT size="+2">Routing in MANET 
(1)</FONT></FONT></B></CENTER>
<P>&nbsp;
<P>After studying the data link layer issue of delivering frames across a 
wireless lik, that is, between adjacent nodes, we move on to data communication
 between nonadjacent nodes. Routing in mobile networks is a very interesting
 problem. 
<P>The routing solution depends on whether the mobile computing model is
 nomadic, cellular, or a MANET. 
<P><B><U>Nomadic computing</U></B>. As mentioned before, this model assumes no 
network connectivity during a move. So, each time a node connects to the 
network, the node could register with appropriate name servers and locate the 
servers that provide the desired services by probing the known directory 
services. Subsequently, packets could be routed to the mobile node. If the 
node's mobility will be hidden, the network could employ Mobile IP. All the 
communicating nodes could route packets to the mobile node's home address. 
There, the home agent would intercept the packets and tunnel them to the mobile 
node. 
<P><B><U>Cellular computing.</U></B> Cellular networks that provide continuous
 connectivity and data communication for mobile nodes take a different approach.
 As a mobile node moves out of one cell into a neighboring cell (or from one 
wireless LAN to a neighboring wireless LAN), seamless handoff between the cells 
is needed. A mobile computing course must discuss this problem for three 
reasons: 
<UL>
  <LI>Unlike with handoff of voice calls in cellular networks, occasional loss
   of a few data packets can severely degrade the performance of several data
   communication applications.</LI>
  <LI>Applications that rely on data communication in a cellular setting will
   become prevalent when third-generation packet radio networks become a 
  reality. The cellular networking domain currently doesn't have many such 
  applications, owing to the low available bandwidth.</LI>
  <LI>Depending on the nature of the application, data packets might or might
   not have delivery deadlines and reliability requirements. So, QoS issues are 
  important in routing decisions. The added dimension of mobility makes the 
  problem more challenging. QoS research and solutions related to backbone
   networks do not necessarily address the issue of source and destination
   mobility.</LI></UL><B><U>MANETs. </U></B>Owing to the absence of any 
infrastructure and the need for all nodes to collaborate in routing and packet 
forwarding, MANET routing is fertile ground for the application of distributed 
computing ideas. While no deployed MANETs exist, such networks have interesting 
potential civilian and military applications. Also, this area has several 
interesting proposed solutions and many unsolved problems.&nbsp; While the IETF 
MANET working group is relatively new, similar problems of routing and packet
 forwarding were investigated in the context of DARPA's packet radio networks in 
the '70s and '80s. 
<CENTER>
<P><A name="tipo"></A><B><FONT color="#ff0000"><FONT size="+1">Tipologie di 
routing nelle MANET.</FONT></FONT></B></P></CENTER>
<P>Owing to the dynamic nature of MANETs, any routing protocol for them should 
undergo these tests: 
<UL>
  <LI>What volume of control traffic do you need to propagate routing 
  information?</LI>
  <LI>How much time do the routing tables at all the nodes take to converge 
  after a topology change?</LI>
  <LI>Are there situations when the routing tables might not stabilize?</LI>
  <LI>Does the protocol determine routes that are optimal with respect to the
   metric that is being optimized? Some protocols try to minimize the number of 
  links on the path between the source and destination. Others might have
   different goals, such as load-balancing among all nodes, minimizing energy
   consumption, or minimizing latency.</LI>
  <LI>Wireless links might be unidirectional. Can the routing protocol utilize
   such links? If so, do you need any modifications at the data link layer?</LI>
  <LI>What fraction of packets is dropped owing to nonavailability of routes
   even though the source and destination are part of the same connected 
  component?</LI>
  <LI>What fraction of packets is misrouted?</LI></UL>The answers to these 
questions will determine if the routing protocol is scalable. Such scalability 
will be a requirement for the wide deployment of MANETs. 
<P>Discussing the abundance of proposed routing protocols for MANETs in minute 
detail is neither possible nor useful, especially because several have similar 
design principles. 
<P>You can classify MANET routing protocols on the basis of when routing
 information is gathered or propagated or on the basis of the network's logical 
organization. 
<P>In the first classification, <B><U>routing protocols can be proactive or 
reactive. </U></B>Proactive protocols rely on the periodic exchange of routing 
information between nodes, and are triggered by network topology changes. 
Subsequently, when a node has to forward data packets, it performs a table 
lookup. Proactive protocols have been criticized for incurring high route update 
overheads even when no data communication takes place between nodes. This 
criticism has led to the development of reactive protocols that perform route 
discovery only when there is data to forward and then cache the discovered 
routes. Subsequently, if a source sends additional packets to a destination, it 
can use the cached route information. 
<P>Proactive protocols will definitely lose when communication is infrequent and 
mobility is high (requiring frequent routing updates). However, in the reverse 
situation, reactive protocols might lose their advantage over the proactive 
protocols. Furthermore, reactive protocols suffer from higher latency due to 
on-demand route discovery. 
<P>In terms of the network's logical organization, MANET routing protocols can 
be <B><U>cluster-based and hierarchical, or flat, or a hybrid of the
 two</U></B>. Cluster-based protocols logically divide the network into
 clusters, each having a head. The heads collectively maintain topology
 information and provide information for packet forwarding to their cluster
 members. Flat protocols maintain no such node hierarchy; all nodes maintain
 routing tables. So, when would a hierarchical protocol be better than a flat 
protocol, and vice versa? There does not seem to be significant literature on 
this question. 
<P>Some researchers suggest that nodes should track the <B> location</B> of 
other nodes for packet-forwarding purposes. A packet could be forwarded to a
 neighbor in the destination's general direction, and topology information
 wouldn't need to be disseminated throughout the network.However, such solutions
 work only under some circumstances. Wireless signals do not propagate outward
 in nice circles. Instead, the terrain, the vegetation, the weather, and
 activities by other transmitters influence a received signal's quality. At 
times, the route that a packet should take between two nodes might have little 
correlation to the straight line connecting those nodes. <BR>&nbsp;
<CENTER>
<H2><FONT color="#ff0000">Routing in MANET</FONT></H2></CENTER>In MANET, since 
there is no fixed router available, all the nodes should also serve as 
routers.&nbsp; 
<P><B><FONT color="#ff0000">Wired routing protocol</FONT></B></P>
<P>Per quanto riguarda gli algoritmi di routing per le reti wired, ogni router
 mantiene una tavola in cui per ogni destinazione raggiungibile sono indicati 
sia il netxt hop, cioe' a quale router contiguo devono essere instradati i 
messaggi per quella destinazione, e la distanza per quella destinazione. La 
distanza puo' essere il numero di router intermedi o altra misura utile. Esitono 
2 tipologie:</P>
<UL>
  <LI>Distance vector</LI>
  <LI>Link state</LI></UL>
<P>Il primo tipo e' il piu' vecchio. I router adiacenti (direttamente collegati)
 si scambiano a intervalli fissi o quando cambia la topologia della rete, il
 contenuto, intero o parziale, delle tavole di routing che possiedono. Questo
 significa che ogni nodo ha una conoscenza parziale della rete, non conosce ad
 esempio quali siano i vicini dei vicini.&nbsp; L'algoritmo di ricerca dei
 cammini minimi che si applica e' quello di Bellman Ford.</P>
<P>Nel secondo caso i nodi si scambiano informazioni effettuando dei broadcast e
 si ricostruiscono localmente l'intera topologia (grafo) della rete.&nbsp;
 L'algoritmo implementato e' quello di Dijkstra.</P>
<P>Questi 2 protocolli formano la base dei protocolli wireless di tipo 
proattivo.</P>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><B 
style="mso-bidi-font-weight: normal;"><SPAN style="mso-ansi-language: IT; mso-fareast-language: IT;"><FONT 
color="#ff0000">Metriche per la distanza</FONT> </SPAN></B></P>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;">Quando un pacchetto 
deve essere instradato ed esistono piu` route attraverso cui potrebbe passare 
per arrivare a destinazione viene presa in considerazione la metrica di ogni 
cammino e viene scelto quello con il valore minore. Questa metrica e` un valore 
numerico che rappresenta la distanza tra due nodi. Solo in casi molto 
particolari questa distanza e` effettivamente una distanza fisica, di solito e` 
semplicemente il numero di salti necessari per arrivare a destinazione.<o:p>
&nbsp;</o:p> </SPAN></P>
<P align="center" class="MsoNormal" style="-ms-text-autospace:; mso-layout-grid-align: none;"><IMG 
width="626" height="118" src="Routing%20in%20Manet%20(1)_file/distanza.jpg" 
border="0"> <SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"></SPAN></P>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;">In casi particolari 
possono venir utilizzati altri parametri per calcolare la distanza tra i nodi, 
in particolare su reti senza fili puo` essere utile tenere in considerazione i 
seguenti fattori:<o:p></o:p> </SPAN></P>
<UL>
  <LI>
  <P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
  style="mso-ansi-language: IT; mso-fareast-language: IT;">banda disponibile 
  (vedere figura sopra)</SPAN></P></LI>
  <LI>
  <P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
  style="mso-ansi-language: IT; mso-fareast-language: IT;">energia necessaria 
  per la comunicazione<o:p></o:p>     </SPAN></P></LI>
  <LI>
  <P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
  style="mso-ansi-language: IT; mso-fareast-language: IT;">rapporto 
  segnale/rumore<o:p></o:p>     </SPAN></P></LI>
  <LI>
  <P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
  style="mso-ansi-language: IT; mso-fareast-language: IT;">stabilita` di 
  associazione<o:p></o:p>     </SPAN></P></LI>
  <LI>
  <P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
  style="mso-ansi-language: IT; mso-fareast-language: IT;">informazioni sul 
  posizionamento fisico dei nodi (GPS)<o:p></o:p>     </SPAN></P></LI></UL>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"><o:p></o:p></SPAN><B>Extending 
Traditional Routing to MANET</B></P>A typical routing protocol for MANET would 
have to deal with - 
<UL>
  <LI>dynamic topology</LI>
  <LI>limited bandwidth</LI>
  <LI>no routers</LI>
  <LI>variable capacity : due to the size of the mobile devices.</LI>
  <LI>assymetric links : in some cases the links might not be symmetric causing
   problems to the routing network.</LI>
  <LI>energy constrained operations : due to the limitation on battery life the
   mobile devices are not expected to perform heavy tasks like storing&amp;
   updating routing tables.</LI>
  <LI>wireless vulnerabilities : due to the unreliability of the links changes
   in the links between nodes are frequent.</LI>
  <LI>limited physical security : due to the open medium like wireless which is 
  accessible by all security becomes an important factor.</LI></UL>
<H3>MANET routing protocols</H3>
<UL>
  <LI>Proactive protocols</LI>
  <UL>
    <LI>Extension of traditional routing protocols</LI>
    <LI>Maintain routes between every host pair at all times</LI></UL>
  <LI>Reactive protocols</LI>
  <UL>
    <LI>Determine route if and when needed</LI>
    <LI>Source initiates route discovery&nbsp;</LI></UL>
  <LI>Hybrid protocols</LI>
  <UL>
    <LI>Adaptive; Combination of proactive and reactive</LI></UL>
  <LI>Geographical protocol.&nbsp;</LI>
  <LI>Different metrics</LI>
  <LI>Multicast routing</LI></UL>
<P><B>NOTE</B>:&nbsp;</P>
<UL>
  <LI>Alcuni algoritmi (ad esempio quelli proattivi) hanno bisogno di scambiare  
    periodicamente dei messaggi che possono o no portare informazioni. Vengono   
   normalmente chiamati <B><I>Hello message</I></B>.&nbsp;&nbsp;</LI>
  <LI>Altra caratteristica comune ad alcuni algoritmi e' quella di dover    
  effettuare dei <B><I>flooding</I></B>, cioe' inviare a tutti i nodi    
  raggiungibili della rete lo stesso messaggio. Questa operazione viene    
  effettuata con la collaborazione di ogni nodo che, quando riceve un    
  messaggio di questo genere, lo invia in broadcast in modo da farlo ricevere    
  a tutti i nodi che cadono nel suo range di trasmissione. Normalmente al    
  messaggio e' asseciato un identificatore univoco in modo che lo stesso    
  messaggio non sia ritrasmesso piu' di 1 volta da ogni nodo. C'e' comunque il   
   problema del <B>message storm</B>, cioe' dell'accumularsi di messaggi a    
  causa del broadcast simulataneo. Per evitarlo, un nodo non ritrasmette    
  subito, ma dopo un piccolo tempo scelto random.</LI>
  <LI>Altra cosa comune a tutti i protocolli e' che d<SPAN style="mso-ansi-language: IT; mso-fareast-language: IT;">urante 
  il funzionamento ogni nodo, in base al contenuto dei messaggi che    riceve, 
  mantiene un certo numero di tabelle di routing. Tipicamente ad ogni    dato 
  memorizzato in queste tabelle e` associato un tempo di scadenza, dopo    il 
  quale il dato non e` piu` valido e deve essere 
cancellato.&nbsp;</SPAN></LI></UL>
<P align="center"><IMG width="439" height="482" src="Routing%20in%20Manet%20(1)_file/schema.jpg" 
border="0"></P>
<H3 align="center">&nbsp;</H3>
<H3 align="center"><B><FONT color="#ff0000">Proactive Protocol</FONT></B></H3>
<P><B><FONT color="#ff0000" size="3">Destination-Sequenced Distance Vector 
routing</FONT></B></P>DSDV is an adaptation of a conventional routing protocol 
to ad hoc networks, based on the idea of the classical Bellman-Ford Routing 
(Distance Vector) Algorithm with certain improvements. 
<P>Every mobile station maintains a routing table that lists all available
 destinations, the number of hops to reach the destination and the sequence
 number assigned by the destination node. The sequence number is used to
 distinguish stale routes from new ones and thus avoid the formation of loops. 
The stations periodically transmit their routing tables to their immediate 
neighbors. A station also transmits its routing table if a significant change 
has occurred in its table from the last update sent. So, the update is both 
time-driven and event-driven. The routing table updates can be sent in two 
ways:- a "full dump" or an incremental update. A full dump sends the full 
routing table to the neighbors and could span many packets whereas in an 
incremental update only those entries from the routing table are sent that has a 
metric change since the last update and it must fit in a packet. If there is 
space in the incremental update packet then those entries may be included whose 
sequence number has changed. When the network is relatively stable, incremental 
updates are sent to avoid extra traffic and full dump are relatively infrequent. 
In a fast-changing network, incremental packets can grow big so full dumps will 
be more frequent. 
<UL>
  <LI>In this, packets are routed between nodes of an ad hoc network using 
  routing tables stored at each node.</LI>
  <LI>Each routing table, at each node, contains a list of the addresses of 
  every other node in the network.</LI>
  <LI>Along with each node's address, the table contains the address of the next
   hop for a packet to take in order to reach the node.</LI>
  <LI>In addition to the destination address and next hop address, routing 
  tables maintain the route metric and the route sequence number.</LI>
  <LI>When network topology changes are detected, each node will broadcast a
   routing table update packet.</LI>
  <LI>The update packet starts out with a metric of one. This signifes to each
   receiving neighbor they are one hop away from the node. The neighbors will
   increment this metric (in this case, to two) and then retransmit the update
   packet.</LI>
  <LI>This process repeats itself until every node in the network has received a 
  copy of the update packet with a corresponding metric.</LI>
  <LI>If a node receives duplicate update packets, the node will only pay 
  attention to the update packet with the smallest metric and ignore the 
  rest.</LI>
  <LI>To distinguish stale update packets from valid ones, each update packet is 
  tagged by the original node with a sequence number. The sequence number is 
  monotonically increasing number which uniquely identifies each update packet 
  from a given node.</LI>
  <LI>If the sequence number matches the sequence number in the routing table,
   then the metric is compared and updated.</LI></UL><B>When topology changes</B> 
<UL>
  <LI>Destination advertises new sequence number</LI></UL>
<P>&nbsp;</P>
<P><B><FONT color="#ff0000" size="3"> OLSR (Optimized Link State Routing 
protocol)</FONT></B></P>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;">OLSR e` formalizzato in 
una RFC proposta dal progetto Hypercomm, dell’INRIA1. Attualmente si trova 
ancora in una fase sperimentale, ma il nucleo del protocollo e` ormai ben 
definito e la discussione rimanente verte su alcune estensioni che sono ancora 
in fase di studio.&nbsp;</SPAN></P>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;">OLSR e` un algoritmo di 
tipo proattivo derivato dal Link State, quindi alla partenza ogni nodo collabora 
con i sui vicini per costruire una tabella di instradamento contenente i cammini 
verso tutti i nodi esistenti. E' anche mantenuta la conoscenza della topologia 
della rete. Dopo questa inizializzazione i nodi si scambiano periodicamente dei 
messaggi per mantenere aggiornati i propri </SPAN><SPAN style="mso-ansi-language: IT; mso-fareast-language: IT;">dati 
topologici.<o:p></o:p> </SPAN></P>
<P align="center" class="MsoNormal" style="-ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"><!--[if gte vml 1]><v:shapetype id="_x0000_t75" coordsize="21600,21600"
 o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f"
 stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="_x0000_i1025" type="#_x0000_t75" style='width:150pt;
 height:81.75pt'>
 <v:imagedata src="file:///C:\DOCUME~1\gianuzzi\IMPOST~1\Temp\msohtml1\03\clip_image001.jpg"
  o:title="hoc2"/>
</v:shape><![endif]--> 
<SPAN style="mso-spacerun: yes;">&nbsp;&nbsp;&nbsp; </SPAN><IMG width="626" 
height="340" src="Routing%20in%20Manet%20(1)_file/hoc2.jpg" border="0"><o:p> 
</o:p> </SPAN></P>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;">Come suggerisce il nome 
dell’algoritmo, OLSR utilizza il flooding delle informazioni sullo stato di 
tutti i collegamenti conosciuti ad ogni nodo per permettere la ricostruzione 
della topologia di rete. Questo flooding viene pero` ottimizzato per limitare al 
massimo lo spreco di banda utilizzando un </SPAN><SPAN style="mso-ansi-language: IT; mso-fareast-language: IT;">sistema 
chiamato MultiPoint Relaying (MPR). </SPAN><SPAN style="mso-ansi-language: IT; mso-fareast-language: IT;"> 
</SPAN></P>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;">La tecnica MPR nasce 
dall’osservazione che in una situazione di broadcast non ottimizzato ogni nodo 
riceve piu` volte le stesse informazioni causando un notevole spreco di banda e 
di potenza di calcolo. Questa situazione puo` essere migliorata scegliendo un 
particolare sottoinsieme di nodi che possono ritrasmettere le informazioni. Le 
figure sotto mostrano la differenze nel numero di ritrasmissioni.<o:p></o:p> 
</SPAN></P>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;">In OLSR ogni nodo 
sceglie un sottoinsieme dei suoi vicini simmetrici tale che ogni secondo vicino 
sia raggiungibile tramite questo sottoinsieme. E` stato dimostrato che questa 
scelta e` NP-completa, infatti l’RFC, nella sezione 8.3.1, descrive un semplice 
algoritmo euristico per calcolare il sottoinsieme MPR.</SPAN></P>
<P align="center" class="MsoNormal" style="-ms-text-autospace:; mso-layout-grid-align: none;"><IMG 
width="431" height="200" src="Routing%20in%20Manet%20(1)_file/due.jpg" border="0"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"><o:p> </o:p> 
</SPAN></P>
<P align="center" class="MsoNormal" style="-ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"><o:p><I>&nbsp;(1) 
Broadcast completo: ogni nodo riceve piu` volte le informazioni, direttamente ed 
in seguito a rimbalzi sui nodi vicini.</I><o:p> </o:p> <BR>(2) <I>Broadcast MPR: 
il nodo centrale seleziona un certo numero di vicini come MPR e solo questi 
ultimi effettuano la ritrasmissione. Il numero di comunicazioni e` di molto 
inferiore</I><o:p> </o:p> </o:p></SPAN></P>
<P align="left" class="MsoNormal" style="-ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;">Il sistema MPR viene 
usato come metodo di default per la ritrasmissione dei messaggi e fa parte del 
nucleo di OLSR che deve essere presente in tutte le implementazioni, consentendo 
a tutti i nodi appartenenti ad una<SPAN style="mso-spacerun: yes;">&nbsp;
</SPAN>rete di ritrasmettere correttamente i messaggi anche senza comprenderne
 il contenuto. </SPAN><SPAN style="mso-ansi-language: IT; mso-fareast-language: IT;">OLSR 
utilizza pacchetti UDP per trasferire le informazioni di controllo, ogni 
pacchetto puo` contenere piu` di un messaggio, proveniente da mittenti
 differenti, per meglio sfruttare il tempo di trasmissione. <o:p></o:p> 
</SPAN></P>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"><o:p>I messaggi 
richiesti dalla funzionalita` base di OLSR sono:<o:p></o:p> </o:p></SPAN></P>
<UL>
  <LI>
  <P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
  style="mso-ansi-language: IT; mso-fareast-language: IT;">HELLO: inviati ad 
  intervalli regolari, compiono le funzioni di rilevamento    dei vicini, 
  comunicazione dei nodi MPR e link sensing<o:p></o:p>     </SPAN></P></LI>
  <LI>
  <P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
  style="mso-ansi-language: IT; mso-fareast-language: IT;">TC: servono a 
  comunicare informazioni topologiche dal punto di vista di ogni    
  nodo<o:p></o:p>     </SPAN></P></LI>
  <LI>
  <P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
  style="mso-ansi-language: IT; mso-fareast-language: IT;">MID: usati dai nodi 
  con piu` interfacce per dichiararne l’esistenza al    resto della 
  rete.<o:p></o:p>     </SPAN></P></LI></UL>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"><o:p>Per evitare che i 
nodi compiano trasmissioni sincronizzate (e quindi che i pacchetti collidano 
sulla rete provocando uno storm), l’RFC stabilisce che prima di ogni invio un 
nodo debba aspettare un tempo casuale.</o:p></SPAN><SPAN style="mso-ansi-language: IT; mso-fareast-language: IT;"> 
</SPAN></P>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;">Ogni volta che avviene 
una variazione viene applicato un algoritmo shortest path sul grafo indiretto 
che ha come nodi tutti i nodi della rete conosciuti e come archi i link 
bidirezionali tra primi vicini, ricostruendocosi' l’intera topologia, e quindi 
la tabella di instradamento.<o:p>&nbsp;</o:p></SPAN></P>
<P style="text-align: justify;"><FONT color="#ff0000" size="3"><SPAN style="mso-ansi-language: IT;"><B><SPAN 
style="mso-ansi-language: IT;">Fisheye State Routing<SPAN style="mso-ansi-language: IT; mso-spacerun: yes;">&nbsp;
</SPAN>(Link State)</SPAN></B></SPAN></FONT><SPAN 
style="mso-ansi-language: IT;"><o:p> </o:p> </SPAN></P>
<P class="MsoNormal" style="text-align: justify;"><o:p>Questo algoritmo cerca di 
migliorare i protocolli Link State riducendo la dimensione dei messaggi di 
update. La figura sotto mostra l’applicazione di Fisheye in una rete wireless. I 
cerchi con differenti gradazioni di grigio definiscono lo scope di fisheye 
rispetto al nodo centrale (nodo 11).</o:p></P>
<P class="MsoNormal" style="text-align: justify;">Lo scope è definito come
 l’insieme di nodi che possono essere raggiunti in un certo numero di hop.</P>
<P class="MsoNormal" style="text-align: justify;">Nel nostro caso sono mostrati
 gli scope per uno, due e tre hop rispettivamente. I nodi sono colorati in nero,
 grigio e bianco a seconda della loro posizione.</P>
<P align="center" class="MsoNormal" style="-ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"><SPAN lang="EN-GB" 
style='font-family: "Times New Roman"; font-size: 12pt; mso-ansi-language: EN-GB; mso-fareast-language: IT; mso-fareast-font-family: "Times New Roman"; mso-bidi-language: AR-SA;'><!--[if gte vml 1]><v:shapetype
 id="_x0000_t75" coordsize="21600,21600" o:spt="75" o:preferrelative="t"
 path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="_x0000_i1025" type="#_x0000_t75" style='width:350.25pt;
 height:229.5pt'>
 <v:imagedata src="file:///C:\DOCUME~1\gianuzzi\IMPOST~1\Temp\msohtml1\05\clip_image001.png"
  o:title="fish"/>
</v:shape><![endif]--> 
<IMG width="494" height="324" src="Routing%20in%20Manet%20(1)_file/f1.jpg" 
border="0"></SPAN></SPAN></P>
<P align="center" class="MsoNormal" style="-ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
lang="EN-GB" style="font-family: Times New Roman; font-size: 12pt; mso-ansi-language: IT; mso-fareast-language: IT; mso-fareast-font-family: Times New Roman; mso-bidi-language: AR-SA;"><I>Scope
 di fish eye</I></SPAN></P>
<P class="MsoNormal" style="text-align: justify;">La riduzione della dimensione
 dei messaggi di update è ottenuta usando diversi periodi di aggiornamento per
 le varie voci della tabella dei link. Più precisamente le voci corrispondenti
 ai nodi entro lo scope più piccolo sono propagate ai vicini con la frequenza 
più alta di tutte. Nella figura sotto vediamo un esempio con 6 nodi.</P>
<P align="center" class="MsoNormal"><SPAN style='font-family: "Times New Roman"; font-size: 12pt; mso-ansi-language: IT; mso-fareast-language: IT; mso-fareast-font-family: "Times New Roman"; mso-bidi-language: AR-SA;'><!--[if gte vml 1]><v:shapetype id="_x0000_t75"
 coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe"
 filled="f" stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="_x0000_i1025" type="#_x0000_t75" style='width:342pt;
 height:239.25pt'>
 <v:imagedata src="file:///C:\DOCUME~1\gianuzzi\IMPOST~1\Temp\msohtml1\07\clip_image001.png"
  o:title="fish2"/>
</v:shape><![endif]--> 
 <IMG src="Routing%20in%20Manet%20(1)_file/tavola.jpg" border="0"></SPAN></P>
<P class="MsoNormal" style="text-align: justify;">Consideriamo per esempio la
 tabella del nodo 1: nella prima porzione(GST) viene memorizzato per ogni nodo
 l’insieme degli altri nodi che può raggiungere in un hop. Questa parte di
 tabella sarà uguale per ogni nodo. La seconda porzione (HOP), memorizza per
 ogni nodo la sua distanza misurata in hop dal nodo 1.</P>
<P class="MsoNormal" style="text-align: justify;">Visto che ogni nodo conosce la
 sua distanza in hop da tutti gli altri, scambierà più frequentemente le
 informazioni riguardanti i nodi più vicini (voci in grassetto nella figura 4) e
 meno frequentemente le altre. In questo modo la dimensione dei messaggi di
 update diminuisce notevolmente.</P>
<P class="MsoNormal" style="text-align: justify;">Il difetto di questo algoritmo
 è che gli spostamenti di nodi a grande distanza da un nodo X verranno
 conosciuti con più ritardo da X. La conoscenza imprecisa del cammino migliore
 per una destinazione distante però è compensata dal fatto che l’instradamento
 diventa più accurato via via che il pacchetto si avvicina a destinazione.</P>
<P align="left" class="MsoNormal" style="-ms-text-autospace:; mso-layout-grid-align: none;">In
 conclusione, FSR si adatta bene a grandi reti mantenendo basso lo scambio dei
 link state senza compromettere l’accuratezza quando la destinazione è 
vicina.</P>
<H3>&nbsp;</H3>
<H3 align="center"><B><FONT color="#ff0000">Reactive Protocol</FONT></B></H3>
<P><FONT size="3"><B><FONT color="#ff0000">Dynamic Source Routing 
(DSR)</FONT></B></FONT></P>[David .B Johnson &amp; David A. Maltz] 
<P>The Dynamic Source Routing Protocol&nbsp; is a source-routed on-demand
 routing protocol. A node maintains route caches containing the source routes
 that it is aware of. The node updates entries in the route cache as and when it 
learns about new routes. 
<P>The two major phases of the protocol are: route discovery and route
 maintenance. When the source node wants to send a packet to a destination, it 
looks up its route cache to determine if it already contains a route to the 
destination. If it finds that an unexpired route to the destination exists, then 
it uses this route to send the packet. But if the node does not have such a 
route, then it initiates the route discovery process by broadcasting a route 
request packet. The route request packet contains the address of the source and 
the destination, and a unique identification number. Each intermediate node 
checks whether it knows of a route to the destination. If it does not, it 
appends its address to the route record of the packet and forwards the packet to 
its neighbors. To limit the number of route requests propagated, a node 
processes the route request packet only if it has not already seen the packet 
and it's address is not present in the route record of the packet. 
<P>A route reply is generated when either the destination or an intermediate
 node with current information about the destination receives the route request 
packet. A route request packet reaching such a node already contains, in its 
route record, the sequence of hops taken from the source to this node. 
<CENTER>
<P><IMG width="428" height="578" alt="Creation of record route in DSRP" src="Routing%20in%20Manet%20(1)_file/Rt5.gif" 
nosave=""> 
<P><I>Creation of record route in DSRP</I></P></CENTER>
<P>As the route request packet propagates through the network, the route record 
is formed as shown in figure 1a. If the route reply is generated by the 
destination then it places the route record from route request packet into the 
route reply packet. On the other hand, if the node generating the route reply is 
an intermediate node then it appends its cached route to destination to the 
route record of route request packet and puts that into the route reply packet. 
Figure 1b shows the route reply packet being sent by the destination itself. To 
send the route reply packet, the responding node must have a route to the 
source. If it has a route to the source in its route cache, it can use that 
route. The reverse of route record can be used if symmetric links are supported. 
In case symmetric links are not supported, the node can initiate route discovery 
to source and piggyback the route reply on this new route request. 
<P><B>Assumptions :</B> 
<UL>
  <LI>The diameter of the network is very small</LI>
  <LI>hosts move without notice</LI>
  <LI>the speed of movement is moderate with respect to the latency of the 
  network</LI>
  <LI>hosts can enable promiscuous mode where the hardware can deliver every
   packet received to network driver without filtering based on destination
   address</LI></UL><B>Basic operation</B> 
<UL>
  <LI>When source S wants to send a packet to destination D, but does not know a 
  route to D, S initiates a route discovery</LI>
  <LI>S floods Route Request (RREQ)</LI>
  <LI>Each node appends its own identfier when forwarding RREQ</LI>
  <LI>D on receiving the first RREQ, sends a Route Reply (RREP)</LI>
  <LI>RREP sent on route obtained by reversing the route appended in RREQ</LI>
  <LI>RREP includes the route from S to D, on which RREQ was received by D</LI>
  <LI>S on receiving RREP, caches the route included in the RREP</LI>
  <LI>When S sends a data packet to D, entire route is included in the 
  header</LI>
  <LI>Intermediate nodes use the source route in the packet header to determine
   to whom a packet should be forwarded</LI></UL><B>Route Maintenance</B> 
<BR>During the normal operation the route that has been discovered is stored 
<BR>in the cache of the nodes and this route is constantly monitored and when a 
<BR>link goes down then new route discovery can be initiated. 
<P><B>Optimisations</B> 
<UL>
  <LI>the nodes taking part as intermediates in the route discovery can 
  themselves store the routes discovered so far for later use</LI>
  <LI>if the nodes store the route in their cache then for a route discovery
   request the node can answer form its cache if it is not stale</LI>
  <LI>another optimisation is the initiator specifying the maximum hops the 
  request packet to travel after which the packet dies, which avoids excessive 
  flooding of the network</LI></UL>
<P><BR><B>Advantages</B> 
<UL>
  <LI>Routes maintained only between nodes who need to communicate</LI>
  <LI>Reduces overhead of route maintenance</LI>
  <LI>Caching (at intermediate nodes) can further reduce route discovery 
  overhead</LI></UL><B>Disadvantages</B> 
<UL>
  <LI>Packet header size grows with route length due to source routing</LI>
  <LI>Flood of route requests may potentially reach all nodes in the 
network</LI>
  <LI>Route Reply Storm problem.</LI>
  <LI>Formation of loop : if the reply from the nodes taken from their cache is 
  used and if it contains a route through the initiator itself then appending
   the route blindly can lead to formation of loops</LI>
  <LI>Stale caches will lead to increased overhead</LI></UL>
<P><FONT size="3"><B>Reactive v/s Proactive Trade-offs</B></FONT></P>
<UL>
  <LI>Reactive protocols</LI>
  <UL>
    <LI>Lower overhead since routes are determined on demand</LI>
    <LI>Significant delay in route determination</LI>
    <LI>Employ flooding (global search)</LI>
    <LI>Control traffic may be bursty</LI></UL>
  <LI>Proactive protocols</LI>
  <UL>
    <LI>Always maintain routes</LI>
    <LI>Little or no delay for route determination</LI>
    <LI>Consume bandwidth to keep routes up-to-date</LI>
    <LI>Maintain routes which may never be used</LI></UL>
  <LI>Which approach achieves a better trade-off depends on the trafic and 
  mobility patterns.</LI></UL>
<P style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;">&nbsp;</P>
<P style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><FONT 
color="#ff0000" size="3"><B><SPAN style="mso-ansi-language: IT; mso-fareast-language: IT;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"><B style="mso-bidi-font-weight: normal;">AODV</B><B 
style="mso-bidi-font-weight: normal; mso-ansi-language: IT; mso-fareast-language: IT;">&nbsp;
</B></SPAN><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;">(Ad-Hoc On-Demand 
Distance Vector Routing)</SPAN></SPAN></B></FONT><B style="mso-bidi-font-weight: normal;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"><o:p> </o:p> 
</SPAN></B></P>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;">AODV&nbsp; (RFC3561) e` 
un protocollo reattivo sviluppato sulla base del protocollo DSDV10. E’ stato 
introdotto nel 1997 ed e` progettato per funzionare in reti da poche decine fino 
a migliaia di nodi. Una proprieta` di AODV e` di usare un destination sequence 
number per ogni entrata nella tabella di routing. Questo numero di sequenza e` 
creato dal nodo destinazione ed e` spedito al nodo sorgente tramiteun route 
reply o un route request. Questo numero e` molto importante poiche' e` semplice 
da implementare nei nodi ed assicura che non ci siano loop nei </SPAN><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;">cammini di 
route.&nbsp;</SPAN></P>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;">Il suo scopo e`, in 
particolare, di permettere ai nodi della rete di determinare la ‘freschezza’ 
delle informazioni di routing nelle proprie tavole. Se un nodo deve scegliere 
tra due differenti cammini per una certa destinazione, allora selezionera` 
quello con il numero di sequenza maggiore. Essendo un protocollo On-Demand i 
route vengono costruiti solo quando un nodo sorgente lo richiede. AODV 
costruisce i route mediante un ciclo di richieste Route-Request/Route-Reply. 
Vediamo in seguito cosa succede se un nodo vuole comunicare con un 
altro.<o:p></o:p> </SPAN></P>
<P align="center" class="MsoNormal" style="-ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"><!--[if gte vml 1]><v:shapetype id="_x0000_t75" coordsize="21600,21600"
 o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f"
 stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="_x0000_i1025" type="#_x0000_t75" style='width:105.75pt;
 height:70.5pt'>
 <v:imagedata src="file:///C:\DOCUME~1\gianuzzi\IMPOST~1\Temp\msohtml1\03\clip_image001.jpg"
  o:title="r1"/>
</v:shape><![endif]--> 
<IMG width="441" height="293" src="Routing%20in%20Manet%20(1)_file/ro1.jpg" 
border="0"></SPAN></P>
<P class="MsoNormal" style="text-align: justify;"><SPAN lang="EN-GB"><o:p> Al 
contrario di DSR, che include nell'header di ogni pacchetto il cammino che deve 
compiere e che puo' utilizzare strade diverse da sorgente a destinazione e 
viceversa, AODV costruisce per ogni nodo le classiche tabelle di routing, per 
cui ogni nodo conosce solo a quale vicino deve inviare il messaggio.</o:p> 
</SPAN></P>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;">Quando un nodo sorgente 
desidera un route verso una destinazione per la quale non ha gia` un percorso, 
manda in broadcast nella rete un pacchettoRoute Request (RREQ).</SPAN></P>
<P align="center" class="MsoNormal" style="-ms-text-autospace:; mso-layout-grid-align: none;"><IMG 
width="546" height="309" src="Routing%20in%20Manet%20(1)_file/ro2.jpg" border="0"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"><o:p> </o:p> 
</SPAN></P>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;">I nodi che ricevono 
questo pacchetto aggiornano le loro informazioni sul nodo sorgente e settano un 
puntatore indietro al nodo sorgente nelle proprie tabelle di routing.</SPAN></P>
<P align="center" class="MsoNormal" style="-ms-text-autospace:; mso-layout-grid-align: none;"><IMG 
width="532" height="315" src="Routing%20in%20Manet%20(1)_file/ro3.jpg" border="0"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"><o:p> </o:p> 
</SPAN></P>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"><o:p>In aggiunta 
all’indirizzo IP del nodo sorgente, dell’indirizzo della destinazione, numero di 
sequenza e ID di broadcast, il pacchetto RREQ contiene, se il nodo sorgente ne 
ha uno, il piu` recente numero di sequenza del nodo destinazione.<SPAN style="mso-spacerun: yes;">&nbsp; 
</SPAN>Un nodo che riceve un pacchetto RREQ puo` spedire al sorgente un 
pacchetto Route Reply (RREP se e` il nodo destinazione oppure se e` a conoscenza 
di un percorso per il nodo destinazione con un numero di sequenza maggiore o 
uguale a quello contenuto nel pacchetto RREQ.<o:p></o:p> </o:p></SPAN></P>
<P align="center" class="MsoNormal" style="-ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"><o:p>&nbsp;<IMG width="532" 
height="319" src="Routing%20in%20Manet%20(1)_file/ro4.jpg" 
border="0"></o:p></SPAN></P>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;">In questo caso il 
pacchetto RREP e` inviato in unicast al nodo sorgente.</SPAN></P>
<P align="center" class="MsoNormal" style="-ms-text-autospace:; mso-layout-grid-align: none;"><IMG 
width="637" height="356" src="Routing%20in%20Manet%20(1)_file/ro5.jpg" border="0"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"><o:p> </o:p> 
</SPAN></P>
<P align="left" class="MsoNormal" style="-ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;">Altrimenti il pacchetto 
RREQ e` re-inviato in broadcast. I nodi tengono traccia dell’indirizzo IP del 
mittente e dell’ID di broadcast di ogni pacchetto RREQ. Se ricevono un pacchetto 
RREQ che e` stato gia` processato lo scartano.Dopo aver stabilito un percorso i 
due nodi possono comunicare tra loro.</SPAN></P>
<P align="center" class="MsoNormal" style="-ms-text-autospace:; mso-layout-grid-align: none;"><IMG 
width="503" height="298" src="Routing%20in%20Manet%20(1)_file/ro6.jpg" border="0"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"><o:p> </o:p> 
</SPAN></P>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"><o:p>Se successivamente 
il nodo sorgente riceve un RREP con numero di sequenza maggiore oppure uguale ma 
con un numero di hop minore puo` nuovamente aggiornare la propria tavola di 
routing e usare il percorso migliore.<o:p></o:p> </o:p></SPAN></P>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"><o:p>Finche` un 
percorso rimane attivo puo` continuare ad essere mantenuto nelle tavole di 
routing. Un percorso puo` essere considerato affivo finche` ci sono pacchetti 
che periodicamente viaggiano dalla sorgente alla destinazione lungo il cammino. 
Quando un nodo sorgente interrompe l’invio di pacchetti, </o:p></SPAN><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;">i links possono essere 
interrotti per via del time-out ed eventualmente possono essere cancellati dalle 
tabelle di routing dei nodi intermedi. Se un link viene interrotto quando il 
percorso e` ancora attivo, il nodo che si trova presso il link interrotto manda 
un pacchetto Route Error (RERR) al nodo sorgente </SPAN><SPAN style="mso-ansi-language: IT; mso-fareast-language: IT;">per 
informarlo che la destinazione non e` piu` raggiungibile.</SPAN></P>
<P align="center" class="MsoNormal" style="-ms-text-autospace:; mso-layout-grid-align: none;"><IMG 
width="619" height="359" src="Routing%20in%20Manet%20(1)_file/ro7.jpg" border="0"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"><o:p> </o:p> 
</SPAN></P>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;"><o:p>
&nbsp;</o:p></SPAN><SPAN style="mso-ansi-language: IT; mso-fareast-language: IT;">In 
questo caso il nodo sorgente puo` decidere se ricominciare o no il route
 discovery.<o:p></o:p> </SPAN></P>
<P class="MsoNormal" style="text-align: justify; -ms-text-autospace:; mso-layout-grid-align: none;"><SPAN 
style="mso-ansi-language: IT; mso-fareast-language: IT;">Oltre al routing 
unicast, AODV e` in grado di gestire, in maniera simile, anche il routing 
multicast. AODV puo` formare e mantenere degli alberi che connettono i membri di 
gruppi multicast. Questi alberi sono composti dai membri dei gruppi e dai nodi 
necessari per connetterli.<o:p>&nbsp;</o:p></SPAN></P>
<P>
<HR width="100%">
<BR>&nbsp;
<DIV align="right"><A href="http://www.disi.unige.it/person/GianuzziV/MobComp/lucidi/Routing2.html">next</A></DIV></BODY></HTML>
