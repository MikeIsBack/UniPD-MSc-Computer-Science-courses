--Appunti su R Lab--

R e' ad oggetti

Con il comando:
ls()
ci assicuriamo che la memoria della sessione sia vuota. In caso non lo fosse, il comando:
rm(list=ls())
la pulira' per noi

C'e' un dataset, Boston, che danno tutte le informazioni riguardo le caratteristiche delle abitazioni della citta'. Questo dataset va caricato ma e' gia' presente in R. Per caricare una libreria e':
library()
Noi caricheremo la libreria MASS. Il comando e':
library(MASS)

Ci son due modi di caricare una libreria: da dataset interno o da file esterno.
Per caricare boston il comando da dare e':
data(Boston)
Questi comandi non restituiscono niente, ma dando ls() vedremo che ora e' presente in memoria.
Scrivendo
Boston
Vedremo la porzione finale dei dati presenti nel dataset. I dati presente nel dataset sono gia' divisi per righe e colonne. La dimensione dei dati si vede con:
dim(Boston)
Tutti gli output forniti da R sono forniti con il numero di righe dell'output, presente in parentesi quadre.
R puo' fornire degli aiuti, riguardo funzioni, dataset, pacchetti ecc ecc. Il comando per chiamare un aiuto e' sempre lo stesso. Le possibilita' sono:
- ?Boston
- help(Boston)
Con questo comando avremo le informazioni riguardo al pacchetto Boston.
Noi per il momento ci concentreremo su:
- medv
- lstat

Si accede alle informazioni attraverso gli oggetti o a parte di vettori/matrici con le parentesi quadre. Le parentesi grafe servono per quando costruiremo noi codice.
In questo caso, per accedere a righe e colonne sarebbe:
Oggetto[righe,colonne]

Con Boston quindi scriviamo:
Boston[1, ]
Per ottenere la prima riga e tutte le colonne, mentre per ottenere tutte le righe ma solo la terza colonna dobbiamo scrivere:
Boston[,3]

La selezione con i : e' il modo compatto per definire un range.
Se noi scriviamo
1:3
Stampa 1 2 3

Quindi se scriviamo
Boston[1:3,]
Otteniamo le prime tre righe di tutte le abitazioni.

L'operatore
c()
Concatena gli elementi specificati all'interno.
Se scrivo
c(1,2,3)
Sarebbe come scrivere 1:3.
Quindi e' uguale scrivere:
Boston[c(1,2,3),]

La differenza e' che : funziona solo con i valori, c() funziona un po' con tutto.
Quando creiamo dei nostri oggetti e usiamo c() la funzione viene sovrascritta.
Per scrivere dei commenti in R si prepone il cancelletto (#) alla riga
#questo e' un commento boys
Per accedere alle variabili si utilizza la funzione attach(), che salva le variabili in memoria. E' quindi importante prestare attenzione tra le varie sessioni.
Potremmo fare attach(Boston) e queste variabili resterebbero in memoria fino al detach. E' quindi meglio fare l'accesso in memoria in modo "formale".

Proviamo ora ad accedere alla variabile _medv_, che sarebbe la nostra Y. Per accedere a una variabile si usa l'operatore $
Boston$medv

Per associare un nuovo oggetto a Y il comando in R e' questo (comando di associazione)
y <- Boston$medv
Se ora vediamo la memoria con ls() vedremo che y e' presente in memoria
Creiamo anche la variabile x, che e' tutto quello che ci serve per avere il modello di regressione lineare semplice di y su x.
x <- Boston$lstat
Ora ci servono il numero delle osservazioni n. In generale, chiediamo ad R dicendogli che e' il numero delle righe del dataset. Scriviamo quindi
n <- nrow(Boston)
Le cose che si guardano di solito sono tre:
1 - Una indicazione semplice di quantili e queste cose qui.
  Per fare cio', diamo il comando
  summary(y)
  Il comando summary() applicate ad un oggetto ci danno una serie delle infoamzioni:
  - Il prezzo mediano
  - La media del costo delle case
  - Il primo e il terzo quantile
  - Il minimo e il massimo costo delle case
  +------------------------------------------------+
  | Min. 1st Qu.  Median    Mean 3rd Qu.    Max.   |
  | 5.00   17.02   21.20   22.53   25.00   50.00   |
  +------------------------------------------------+
  summary() risponde diversamente in base ai parametri che gli vengono passati.
2 - Costruire un istogramma. Per costruire un istogramma e' presente il comando hist.
  hist(y,
  Poi sono presenti dei parametri opzionali, che possono essere dei parametri grafici. Di solito si mette come secondo parametro:
  prob=TRUE
  Questo parametro e' importante che sia passato. Il comando finale quindi sara':
  hist(y, prob=TRUE)
  Questo permette ad R di fare un'automatica suddivisione degli intervalli, costruendoli in maniera tale che siano proporzionali al numero delle abitazioni che si rilevano all'interno di ciascun intervallo di prezzo.
  Per cambiare l'output del grafico dell'istogramma sono disponibili differenti opzioni. Per ogni tipo di grafico le asse delle assisce e delle ordinate e' presente un parametro xlab e ylab. Quindi e' possibile scrivere:
  hist(y, prob=TRUE, xlab='Prezzo mediano delle abitazioni', ylab='Densita di frequenza')
  Importante e' non mettere gli accenti. Per modificare il titolo esiste l'opzione main.
  hist(y, prob=TRUE, xlab='Prezzo mediano delle abitazioni', ylab='Densita di frequenza', main='Istogramma')
  N.B.: l'ordine dei parametri e' irrilevante, e il grafico dovrebbero essere self-contained.
3 - Boxplot() e' un altro comando utile, e lo possiamo dare con
  boxplot(y)
  E ci permette di vedere la distribuzione. Le linee tratteggiate nel grafico corrispondono alle rappresentazione che si trovano distanti dalla "scatola" 1.5 volte e mezzo. Oltre i "baffi" del diagramma si hanno le parti piu' estreme della distribuzione, e sono tutte osservazioni molto lontane dal centro, e sono valori molto lontani rispetto alla media.
  Piu' informazioni sono dentro la scatola piu' informazioni sono dentro il primo e terzo quartile.
  E' possibile costruire una unica finestra grande con due colonne, uno con il comando visto in 3 e un'altro con il comando visto in 2. Il comando e':
  par(mfrow=c(1,2))
  par richiede la specificazione di un parametro grafico, e permettono ad esempio di ridurre margini grafici e cose simili. In questo caso, ci permette di rompere l'immagine in una riga e due colonne. mfrow sta per "divisione in righe". Il suo corrispondente per le colonne e' "mfcol"
4 - Ora vogliamo visualizzare il diagramma di dispersione per y=beta0 + beta1 x + epsilon, che lo possiamo ottenere con:
  plot(x,y, pch=19)
  pch e' un pallino piccolo pieno, che permette di avere una migliore visualizzazione.

Ripassando quanto visto in teoria, avremmo:
- beta1 stimato: cov(x,y)/var(x)
- beta0 stimato: media(y)-beta1.stimato * media(x)
Per ottenere beta1 stimato dovremmo fare:
beta1.stimato <- cov(x,y)/var(x)
E' sempre importante ricordare che sarebbe: sum((xi-mean(x))^2)/(n-1)
Per ottenere beta0.stimato dobbiamo scrivere:
beta0.stimato <- mean(y) - beta1.stimato * mean(x)
La retta stimata sarebbe quindi: y*=34.55384-0.9500494*x
Ora stimiamo il modello di regressione con le funzionalita' di R. Il comando e' che utilizzeremo e' lm (che sta per _linear model_), e serve a stimare i modelli lienari. E' indispensabile che ci sinoa due parametri in paricolare:
- La formula
- I dati
Tutti gli altri sono opzioni particolari che non sempre useremo.
Ora creiamo il nostro modello, che lo chiameremo modello.
modello <- lm (y ~ x, data=Boston)
Con l'operatore ~ serve per specificare l'operatore x. L'informazione che lm ci da e' troppo scarna, ed e' quindi necessario vedere il summary. Diamo quindi:
summary(modello)
Memo: la mediana dovrebbe avere media nulla e i quartili dovrebbero essere simmetrici.
Le stelline nell'ouput che abbiamo vanno in ordine di qualita' del p-value:
*** = bene
** = meno
* = poco
. = niente
'' = p-value e' 1

E' possibile vedere altre informazioni all'iterno dell'oggetto modello.
Per visulizzarle, e' necessario digitare
names(modello)
che ci dara' tutto quello presente all'interno dell'oggetto.
Come possiamo rappresentare sul grafico dei punti quello che abbiamo stimato?
Possiamo:
1 - Aggiungiamo l'aggiunta della retta al grafico gia' esistente, che si fa con il comando
  abline()
  Che significa: intercetta a con inclinazione b. Quindi ora diamo:
  abline(a=modello$coefficients[1], b=modello$coefficients[2], col='red', lwd=2)
  Dove col e' il colore e lwd e' lo spessore della linea.
  Se vogliamo sapere i valori stimati del modello possiamo dare:
  valori.stimati <- modello$fitted.values
  Oppure:
  valori.stimati <- fitted(modello)
  Queste due funzioni sono uguali.
  Ora possiamo aggiungere dei punti al grafico. Per falo, usiamo points(), dove dobbiamo passare le x e le y rispettivamente.
  points(x, valori.stimati, col='green', pch='x')
  Le fitted sono i dati stimati sul training set, e sono i dati che servono per custruire il modello. Le previsioni esterne sul test set richiedono il comando predict. Quindi dovremo usare il comando previsione e non fitted quando saremo sul test set. Questo perche' se io dico predict(modello) senza specificare il test set esterno R ci da la stessa cosa di fitted(modello). Questo perche' all'interno del training set i valori sono quelli.




Per chiudere il modello se abbiamo fatto il detach dovremmo fare il detach.
Per uscire usiamo:
q()
Dove R ci chiede se vogliamo salvare la sessione o meno.
